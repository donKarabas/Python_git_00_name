
Ссылка на все уроки:
https://gist.github.com/ithobbies

ю-туб видео 10 уроков
https://www.youtube.com/playlist?list=PL4sJ_PtqW49AVCkGAVWQXsXaiRUlruX-G

ITH
﻿Телеграм канал для общения - https://t.me/ithband
Группа в VK - https://vk.com/ithobbies
Телеграмм канал - https://t.me/ithobbies

----------------------------
----------------------------

#01

Frame - объект библиотеки tkinter, от которого наследуется класс главного окна Main(tk.Frame)
Frame - это контейнер, который служит для организации объектов и виджетов внутри окна.

Создаётся конструктор класса - специальный метод, который автоматически вызывается при создании класса и придаёт ему два аргумента. Первый - это текущий экземпляр класса (self), второй - корневое окно программы (root)
Возьмём метод __init__() у базового класса Frame() и передадим в него аргументы root, переданные в __init__() производного класса Main()
Метод super() отыскивает базовый класс у класса Main() и возвращает его, а дальше уже идёт обращение к методу __init__() этого найденного класса.
Польза в том, что при изменении родительского класса не придётся изменять содержимое метода, а также даёт возможность корректно использовать класса в наследовании.

Условная конструкция if __name__ == "__main__":
Инструкция создаёт корневое окно программы.
Размеры окна и точку, где оно будет появляться.

---------

#02

Создаём и вызываем дочернее окно программы, в котором будут располагаться поля ввода необходимых нам данных. Реализуем панель управления (toolbar) и создадим вместо традиционной кнопки кнопку с необходимой нам иконкой.

Создаём новую функцию init_main() в которой будем хранить и инициализировать все объекты графического интерфейса.
Вызываем функцию из конструктора класса.

Создаём панель инструментов. Сама по себе она будет представлять несколько кнопок навигации, через которые мы будем взаимодействовать с программой.
toolbar будем реализовывать с помощью уже известного нам объекта Frame. Также передадим ему два аргумента: цвет фона контейнера и толщину границы.

В метод pack передаём два аргумента: первый закрепит панель в верхней части окна, второй растянет панель по горизонтали.

Создаём класс дочернего окна, наследуемся от объекта Toplevel. Toplevel - это окно верхнего уровня, которое служит для создания многооконных программ и дочерних окон.
Создаём конструктор класса и прописываем метод super. 

Пишем функцию, в которой будем инициализировать обекты и виджеты окна.

Добавим дочернему окну свойства, присущие модальному. А именно, будем перехватывать все события, происходящие в приложении и удерживать фокус на нём до момента его закрытия. Это значит, что пока мы работаем с дочерним окном, пользователь не сможет закрыть главное или как-то взаимодействовать с ним. Дочернее окно будет всегда поверх основного.
Метод grab_set() перехватывает все события, происходящие в приложении.
Метод focus_set() захватывает и удерживает фокус.

Пишем функцию, которая отвечает за вызов дочернего окна.

Указать вызов функции init_child()

Вызываем класс, который умеет читать изображения.

Напишем код кнопки "Добавить позиции", укажем атрибуты.

-------------

# 03

Далее нам надо отобразить в программе наши данные из БД в виде таблицы. В tkinter такого виджета нет, но в tkinter есть модуль расширения ttk, который имеет виджет Treeview, что поможет нам обойти ограничение.

Добавим виджет Treeview на главное окно программы. Передадим в виджет несколько параметров: self, далее передадим кортеж (columns) из id наших колонок, которых будет 4. Также укажем параметр show, передадим ему значение headings, чтобы не отображалась нулевая колонка.

Добавим параметры колонкам, которые указали в кортеже. Метод column

Даём привычное название колонкам. Метод heading

Чтобы виджеты Treeview отображались в главном окне, применим метод pack

Чтобы добавить данные в таблицу, необходима форма ввода. Есть дочернее окно, которое открывается по нажатию на кнопку с ярлыком "добавить позицию" (class Child). Добавим в это окно элемент для ввода данных. Поля ввода данных организуются с помощью виджета Entry. 
Укажем виджету координату места расположения с помощью метода place.
Поле для ввода суммы денег.

Реализуем выпадающий список с выбором необходимых опций. Для этого нам необходимо использовать виджет combobox. В параметр volues указываем список выбора необходимых нам элементов. Чтобы один из пунктов отображался по умолчанию, применим метод current. В скобках (параметрах) указываем индекс пункта из списка, который мы хотим отображать по умолчанию.
Расположим combobox по заданным координатам. 

Подписываем поля ввода с помощью виджета Label.

Создаём две кнопки. Первая будет осуществлять действия добавления содержимого, которое мы будем вводить в поля ввода. Вторая будет просто закрывать дочернее окно. Функцию закрытия окна будет выполнять метод destroy, который мы укажем в параметрах.

Укажем, чтобы кнопка добавления ("Добавить") срабатывала по нажатию левой кнопки мыши. Метод bind.

-------------

# 04

Импортируем модуль sqlite3

Реализуем новый класс, который будет отвечать за работу с БД.
Создадим конструктор класса.

Создадим соединение с БД методом connect класса Connection, который возвращает объект соединения. В нашем случае это будет файл с расширением db.
Создание объекта cursor класса Cursur. Объект позволяет взаимодействовать с БД.
Создадим таблицу базы данных методом execute объекта cursor. В качестве аргумента метода execute будет строка запроса на языке sqlite.
Сохраняем изменения в БД методом commit класса Connection.

--------------

# 05

Попытаемся реализовать добавление записи в базу данных по нажатию кнопки добавить дочернего окна программы. Того самого окна, в котором мы вводим информацию о наших доходах и затратах.
Реализуем функцию, которая будет находиться в классе DB и будет выполнять sql запрос к базе для занесения в неё данных.

Создадим функцию insert_data, которая будет на вход получать значения из трёх переменных: значения с виджетов и combobox.
Создадим VALUES, первый аргумент метода execute, где используем подстановку параметров "?". Вторым аргументом метода execute предоставим кортеж значений.

Создадим в классе Main промежуточную функцию record, которая будет служить нам в качестве вызова двух других функций: insert_data и передавать в эту функцию значения из дочернего окна, а также функции, которая будет брать содержимое базы данных и отображать таблицы виджета Treeview.
Функция record будет принимать значения тех же трёх переменных, как и функция insert_data.

Для того, чтобы обращаться к функциям класса DB из класса Main, необходимо создать экземпляр класса DB. Далее, созданный экземпляр класса подаём в конструктор класса Main. Теперь мы можем обращаться к функциям и методам класса DB из класса Main через простую переменную db.

Вызовем из функции records функцию insert_data класса DB.

Реализуем функционал кнопки "добавить" дочернего окна программы. Так как по нажатию кнопки "добавить" данные из виджетов entry и combobox необходимо передавать на вход функции records класса Main, нам придётся обращаться к данной функции из класса Child.
Соответственно, передадим класс Main в класс Child, после чего мы сможем свободно обращаться к функции records. 
Теперь мы можем с помощью метода get получить значение из виджетов и сразу же передать в функцию records.

Для того чтобы отобразить информацию из базы данных в виджете Treeview главного окна программы, реализуем ранее упомянутую функцию и назовём её view_records.
Первое, что будет выполнять функция, это извлекать данные из таблицы finance из одноимённой базы finance.db. За это будет отвечать SELECT запрос.

Чтобы информация в виджете Treeview отображалась в соответствии с теми данными, что находятся в базе, а не добавлялись и не повторялись снова в полном объёме в виджет, после каждого добавления нового поля реализуем очистку содержимого виджета.
Путём использования генератора списка, в цикле будем получать строки из виджета Treeview с помощью метода get_children и после удалять их, применяя метод delete.

Для того, чтобы отобразить содержимое базы данных, используем также генератор списка, который с помощью метода fetchall будет возвращать список кортежей. Другими словами, последовательности строк, где каждая строка представляет собой последовательность элементов столбца. А затем, используя метод insert, будет добавлять строки в виджет Treeview.
Аргументом методу insert укажем, что новое значение будет добавляться после предыдущего. Также укажем ещё один аргумент values. В нём укажем переменную, которая хранит в себе данные, извлечённые из базы в цикле.

Чтобы при запуске программы, данные автоматически подтягивались и отображались в виджете Treeview, вызовем функцию view_records. В первом случае мы будем вызывать её из функции records. Здесь вызов этой функции будет служить для того, чтобы после каждого добавления поля мы опять выполняли данную функцию отображение в виджете Treeview, а также при запуске непосредственно программы в первый раз будем вызывать из конструктора класса Main.

--------------

# 06

Добавим возможность редактировать записи, которые мы ранее добавили в таблицу и базу данных finance. Было бы удобно, чтобы пользователь имел возможность выделить из таблицы главного окна программы необходимую ему запись, нажать, например, кнопку "Редактировать" и ему отображалось окно, в котором он сможет изменить прежние данные.
Начнём с функции, которая будет выполнять нам действие по редактированию или обновлению записей в базе данных finance. Для этого создадим в классе Main функцию update_record. На вход она будет получать значения из полей ввода данных, которые нам уже известны: description, costs, total.

Далее необходимо выполнить SQL-запрос. За это отвечает  известный метод execute.
SQL-запрос, который отвечает за обновление полей таблицы базы данных finance.
Первым делом ключевое слово UPDATE, далее название таблицы finance. Далее указываем поля, которые мы будем изменять, используя команду SET. В качестве заполнителя используем DB?? подстановку параметров и ставим символы знака вопроса в места, где мы хотим использовать значения.
Для того, чтобы сообщить программе, поля какой записи необходимо изменить, укажем команду WHERE ID. ID мы храним в первом столбце таблицы. Для команды WHERE ID также используем DB?? подстановку.
Далее, необходимо передать кортеж значений в качестве второго аргумента метода execute. Кортеж будет содержать значения переменной, которые мы передаём на вход функции update_record, а также ID выделенной нами записи таблицы главного окна программы.
Для того, чтобы получить значение ID выделенной записи, необходимо использовать метод set виджета Treeview. Для того, чтобы метод вернул необходимое значение, укажем ему два аргумента. На этом месте необходимо обратить внимание: 
Первый аргумент, это метод selection, который возвращает список из уникальных идентификаторов выделенных записей в таблице виджета Treeview. Этот идентификатор не тот же самый, который находится в таблице ID. Если мы выделим только одну запись, то список будет всего лишь из одного элемента, так как мы будем обновлять записи построчно, выделяя только одну запись нам из списка необходимо выделить первый элемент. Укажем, что нам нужен первый элемент списка, который находится под индексом [0]. 
Второй аргумент метода set, это из какого столбца возвращать значение. В нашем случае столбец ID это столбец 1 по порядку.
Другими словами. Метод execute выполнит нам SQL-запрос. Первым ключевым словом в нашем щапросе будет UPDATE, оно выполняет функцию редактирования данных. Далее мы указываем, в какой таблице нам необходимо произвести редактирование, это таблица finance. Далее необходимо указать, в каких полях мы будем изменять данные, это description, costs и total. Для того, чтобы указать, где необходимо нам изменить эти данные, мы указываем ID. ID берётся с нашего первого столбца. То есть, мы указываем, что нам необходимо, к примеру, изменить данные в строке 2, выделяя её. Метод set вернёт нам значение id числа 2, но вернёт в том случае, если мы укажем ему два аргумента. 
Первый, это метод selection, который возвращает уникальный id. Метод не возвращает двойку, метод возвращает id двойки. То есть, id ID. И возвращает метод список из id. То есть, если мы выделим две строки: 2 и 3, то метод вернёт спискок: id двойки и id тройки. Так как мы изменяем значения построчно, то указываем в инструкции выбирать первое значение из списка.
Второй аргумент, это из какого столбца мы берём. Мы выделяем строку, метод set вернёт значение id - ID (вот теперь нужная нам двойка), выбирается значение двойки, передаётся далее в WHERE ID=,  и необходимые поля в таблице БД скорректируются.

Сохраним изменения и рельтаты работы с БД, вызовем метод commit класса Connection.

Чтобы отобразить в таблице главного окна обновлённую информацию в базе, вызовем созданную функцию view_records, которая за это отвечает.

Реализуем отдельную форму ввода данных корректировки. Для этого воспользуемся одним из достоинств парадигмы объктно-ориентированного программирования - наследованием. Так как форма ввода данных и формы, которые мы сейчас будем создавать, идентичные, за исключением нескольких моментов, которые мы проговорим ниже, почему бы этим не воспользоваться.

Создадим класс Update, который будет наследоваться от класса Child.
Как любой другой класс, класс Update будет иметь свой конструктор.
Изменим графическую часть окна, а именно title и взамен кнопки "ok" сделаем кнопку "редактировать".
Кнопку "ок" просто удалим.
Укажем title. Назовём его "Редактировать позицию".
Сделаем кнопку "Редактировать".
Разместим кнопку методом place по заданным координатам.

Так как нам по нажатию кнопки "Редактировать" необходимо передать в функцию update_record данные из полей ввода, соответственно реализуем это. Для этого, как нам уже известно, необходимо применить метод get, который получит значение из виджетов и сохранит в переменной.
Воспользуемся методом bind.
Укажем, с каких виджетов (полей) мы будем получать значение.
Чтобы убрать кнопку "ок" используем метод destroy.

Для того, чтобы изменения в графическом интерфейсе отобразились пользователю, вызовем функцию init_edit из конструктора класса Update.
А также, чтобы обращаться к функциям из класса Main, передадим его в тот же конструктор класса Update.

Осталось добавить кнопку "Редактировать" в тулбар главного окна программы.
Перед тем, как добавим кнопку, создадим функцию, которая будет выполняться по нажатию кнопки "Редактировать" и вызывать класс Update.

Кнопку "Редактировать" отнесём к toolbar, укажем атрибут text с названием кнопки, укажем цвет фона, он будет таким же, как у кнопки "Добавить позицию." Для того, чтобы мы могли повесить на кнопку иконку, используем используем класс Photoimage. 
Укажем класс для переменной update_img и укажем путь к иконке. 
Далее добавим кнопке атрибут image и передадим в него переменную update_img, которая хранит в себе нашу иконку.
Так как мы добавили иконку кнопке, укажем атрибут compound, чтобы название кнопки "Редактировать" отображалось под самой иконкой.
Чтобы кнопка вызывала окно редактирования записи, добавим атрибут command и передадим в него вызов функции open_update.

Чтобы кнопка отображалась с левой стороны, после кнопки "Добавить позицию", применим метод pack и укажем атрибут side.

--------------

# 07

Реализуем функцию удаления из приложения и базы данных соответственно.

Создадим новую функцию в классе Main и назовём её delete_records. 
Для того, чтобы из таблицы виджета Treeview мы могли удалять по несколько выделенных записей одновременно, создадим цикл, с помощью которого мы сможем получить список уникальных идентификаторов, которые возвращаем методом selection.
Далее выполним SQL-запрос. С его помощью мы будем удалять запись из таблицы БД finance.
Он формируется следующим образом. 
Используем метод execute и первым аргументом метода будет сам  запрос на языке sqlite. Первым идёт ключевое слово DELETE, далее указываем название таблицы, из которой будем удалять запись. Для того, чтобы указать программе, какие записи необходимо удалить, укажем команду WHERE id. ID мы храним в первом столбце таблицы. В качестве заполнителя используем символ "?".
Второй аргумент метода execute, это естественно картеж значений id выделенных записей в виджете Treeview. Значение id выделенных записей нам вернёт метод set. 
В метод set передадим два аргумента. Первый - наш итератор selection_item, второй - из какого столбца брать значение.
Сохраним все изменения и результаты работы с БД, вызовем метод commit класса Connection.

Чтобы отобразить в таблице главного окна обновлённую информацию БД, вызовем функцию view_records

Ещё раз проговорим реализацию функции delete_records.
Метод selection возвращает список уникальных идентификаторов выделенных нами записей в таблице виджета Treeview. Чтобы можно было обращаться к каждому элементу в отдельности, необходимо использовать цикл. Создаём цикл, в котором пройдём по списку, возвращённым методом selection. В данном цикле будет исполняться SQL-запрос. Запрос будет удалять из базы данных выделенные нами записи. Как запрос узнает, какую запись ему необходимо удалить? Для этого есть метод set, который возвращает значение из конкретной ячейки виджета Treeview. Запустим программу. Если выделить несколько записей (строк), метод selection вернёт их уникальный идентификатор. Иными словами, вернёт их порядковый номер, в каком порядке размещены строки в выделенном нами списке. Второй аргумент, с какого столбца брать значение. Тогда метод set вернёт значение из столбца № 1, из столбца ID. Если мы выделяем строку 2, вернётся число 2, если выделяем строки 1, 2, вернётся список чисел: 1, 2. Далее SQL-запрос удалит из таблицы БД строку с указанным ID, то есть те записи, которые мы выделили.

Создадим кнопку, которая будет вызывать функцию delete_records.

--------------

# 08

Реализация функции поиска по программе.

Сначала исправим ошибку в программе, которая заключалась в том, что если номер ID является двузначным и болеет числом, мы получаем ошибку: sqlite3.ProgrammingError: Incorrect number ... . Чтобы исправить ошибку, необходимо поставить запятую, которая сделает выражение кортежем. 
Запятую ставим в SQL-запросе функции delete_records класса Main. До этого это было выражение, в котором каждое значение являлось отдельным элементом и, соответственно, программа обрабатывала двузначное число ID как две отдельные цифры, а не единое число.

Перейдём к реализации функции поиска в БД по наименованию.

Создадим новый класс Search, который будет наследовать от объекта Toplevel. Объявим конструктор класса.
Создаём новую функцию init_search, которой будем инициализировать все графические объекты интерфейса. Вызывать данную функцию будем через конструктор класса. Конструктор класса автоматически вызывается при запуске прораммы либо при вызове класса и вызываются вложенные в него функции.

Укажем имя и размер окна поиска, а также запретим изменять его размер.
Добавим виджет label с надписью "Поиск".
Добавим поле ввода данных для поиска, используя виджет Entry.

Добавим две кнопки. Первая - "Закрыть окно", вторая будет отвечать собственно за поиск.
О выполнении функций по нажатию кнопки "Поиск" поговорим чуть позже, после реализации самой функции поиска в БД.

Создадим функцию в классе Main, которая будет вызывать окно поиска по нажатию кнопки с главного окна программы.
Добавим кнопку в toolbar, вызывающую окно поиска.

Перейдём к реализации самой функции поиска по наименованию в БД.
Определим функцию search_records. Так как мы будем искать по полю description, передадим на вход данную переменную.
Далее, при формировании SQL-запроса, мы будем использовать оператор LIKE. Оператор LIKE используется вместе с оператором WHERE для поиска в столбце заданного шаблона или, другими словами, слова, фразы, предложения.
Формируем SQL-запрос для поиска заданного наименования дохода, расхода через уже реализованную форму поиска.

Нужно отобразить данные поиска в виджете Treeview. 
Сначала мы очистим содержимое виджета путём использования генератора списка. В цикле будем получать строки из виджета Treeview с помощью метода getchildren и после удалять их применяя метод delete.
Теперь, с помощью всё того же генератора списков, нам необходимо отобразить результаты поиска, используя знакомый нам метод fetchall, который будет возвращать список кортежей, найденных в базе данных, методом insert. insert будет добавлять строки в виджет Treeview.

Для того, чтобы поиск происходил по ключевому слову, находящемуся в любой позиции: начало, середина, конец предложения - используем такой инструмент, как подстановочные символы, с оператором LIKE.
Создаём переменную description, помещаем в неё кортеж, содержащий искомое слово, полученное из окна поиска + два подстановочных символа перед и после искомого слова 
('%' + слово + '%',). Иными словами, переменная description, содержащая в себе искомое слово, полученное из окна поиска, будет заключена в подстановочные символы.

Подведём итог принципа работы поиска. Из окна поиска entry_search. На вход функиции search_records передаём наш запрос. Далее используем подстановочные символы, чтобы программа показывала всю строку, содержащую поисковое слово, а не строку, состоящую только из поискового слова. 
Выполняем SQL-запрос с помощью метода execute, обращаемся к базе данных. Из таблицы finance берём все элементы, обращаемся к полю description, используем оператор LIKE с подстановочным символом ?. На место подстановочного символа мы будем искать в нашей базе строки с содержимым переменной description. 
После того, как были найдены строки по искомому запросу, их необходимо отобразить в виджете Treeview. Для этого сначала очищаем таблицу. Проходим в цикле построчно и методом delete удаляем строки. Чтобы отобразить в таблице строки с найденным запросом, также в цикле используем метод insert с методом fetchall и добавляем необходимые строки.

Добавим вызов функции search_records в кнопку поиска в том же окне поиска.
Чтобы выполнялся собственно поиск, к кнопке btn_search необходимо привязать вызов функции.
Используем метод bind. По нажатию левой кнопки мыши ('<Button-1>').
Для того, чтобы после нажатия кнопки поиск окно автоматически закрывалось, добавим ещё один метод. Используем параметр add, который позволит вешать на одну кнопку вызов нескольких функций.

Для возможности обращения из класса Search к функциям класса Main, необходимо передать класс Main в класс Search. Это делается в конструкторе класса.

Протестируем работу поиска.
Следующая проблема, как после завершённого поиска оптимально вернуть отображение полного содержимого базы данных.
Решим этот вопрос простым введением новой кнопки, которая и отобразит содержимое, тем более, функция отображения содержимого БД уже реализована.

Создадим новую кнопку, которая будет вызывать функцию view_records.

--------------

# 09

Как сделать так, чтобы в окне редактирования подтягивалась предыдущая информация с базы данных о доходах или затратах? Реализуем это решение.

Необходимо создать в классе Update функцию, которая будет извлекать из БД запись, которая в данный момент выделена в таблице основного окна, и помещать информацию в соответствующие поля.
Создадим в классе Update функцию default_data. Данный класс отвечает за редактирование записи. Вызовем сразу данную функцию в конструкторе класса.
Выполним SQL-запрос, который вернёт нам значение из выделенной строки в таблице. Обращаемся к классу базы данных, потом к его курсору и вызовем метод execute. Запрос состоит из оператора SELECT, который извлекает все поля из таблицы finance. В WHERE указываем подстановочный символ ?. 
Вторым аргументом метода execute будет метод виджета Treeview под названием set, который нам и позволит получить значение ID выделенной строки и подставить её в SQL-запрос. ID будет таким же как и в таблице. Не забываем поставить запятую в конце.
Методу set нужно также 2 аргумента: номер столбца и строки, в которой находится значение ID выделенной строки. Первый аргумент метода set, метод selection. Метод selection возвращает кортеж. Нам нужен первый элемент кортежа, индекс которого 0. Второй аргумент метода set, это собственно номер по порядку столбца.

Для того, чтобы из класса Update обращаться в класс DB, передадим его в данный класс. Это необходимо сделать перед вызовом функции default_data.

Теперь создадим новую переменную row, в которую будем сохранять значение полей результата запроса. Используем метод fetchone.
Обращаемся к классу db, к курсору и выполним метод fetchone.

В названия полей ввода нам нужно методом insert ставить значения, полученные из БД.
Начнём с поля "наименование". Так как метод fetchone возвращает нам кортеж, добавим второй элемент - информацию о доходе/расходе с индексом 1, будет началом позиции. 
Статья дохода или расхода выбиралась методом combobox. Если сейчас к combobox применить метод insert, информация из БД добавится некорректно, будет задвоение. Пойдём другим путём. Используем условную конструкцию и будем сравнивать полученное значение из кортежа с индексом 2 со словом "доход".
Поле entry_many будет по подобию поля entry_description.

--------------

# 10

Добавление полосы прокрутки - scrollbar.

Расширим окно на 15 пикселей в установках главного окна root.geometry
Виджет Treeview выравнивается посередине. Чтобы добавить полосу прокрутки, необходимо сместить виджет влево. Находим метод pack виджета Treeview и добавляем параметр side=tk.LEFT

Перейдём к созданию самого виджета scrollbar. 
Для этого создадим переменную scroll, в которую поместим виджет Scrollbar.
Первый параметр виджета это self, вторым будет command. Параметр command вызовет метод yview виджета Treeview. Данный метод позволяет прокрутить содержимое, когда мы перетащим ползунок scrollbara.
Как к любому другому виджету в Tkinter надо применить упаковщик. В данном случае будет использован pack. Первым параметром будет side, установим ему выравнивание по левой стороне. Второй параметр будет fill. Установим ему растягивание по оси Y, то есть по вертикали.

Для того, чтобы связать перемещение по виджету Treeview, например с помощью стрелок, и движение самого scrollbar, необходимо применить для виджета Treeview метод configure и указать параметр yscrollcommand и установить scroll.set.

